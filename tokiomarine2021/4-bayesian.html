<!DOCTYPE html>
<html>
<head prefix="og: http://ogp.me/ns#">
<meta charset="utf-8">
<meta name="viewport" content="width=device-width,minimum-scale=1,initial-scale=1">
<title>4. 階層ベイズモデル — 統計モデリング概論 DSHC 2021</title>
<link rel="stylesheet" href="/slides/lib/reveal.js/reveal.css">
<link rel="stylesheet" href="/slides/css/theme-reveal.css">
<meta name="author" content="Watal M. Iwasaki">
<meta property="og:title" content="4. 階層ベイズモデル — 統計モデリング概論 DSHC 2021">
<meta property="og:type" content="article">
<meta property="og:url" content="https://heavywatal.github.io/slides/tokiomarine2021/4-bayesian.html">
<meta property="og:image" content="https://avatars.githubusercontent.com/heavywatal">
<meta property="og:description" content="">
<meta property="og:site_name" content="Slide decks — Heavy Watal">
<meta name="twitter:card" content="summary">
<meta name="twitter:site" content="@heavywatal">
<meta name="twitter:creator" content="@heavywatal">
<meta name="generator" content="Hugo 0.83.1" />
<link rel="stylesheet" href="/lib/katex/katex.min.css">
<script defer src="/lib/katex/katex.min.js"></script>
<script defer src="/lib/katex/contrib/auto-render.min.js"></script>
<script>
document.addEventListener("DOMContentLoaded", function() {
  renderMathInElement(document.body, {
    delimiters: [
      {left: "\\[", right: "\\]", display: true},
      {left: "$", right: "$", display: false}
    ]
  });
});
</script>
<style>
.katex {
  font-size: 1.12em;
}

.katex-display > .katex {
  text-align: left;
  padding-left: 2rem;
}
</style>

<script defer src="https://use.fontawesome.com/releases/v5.8.2/js/all.js" integrity="sha384-DJ25uNYET2XCl5ZF++U8eNxPWqcKohUUBUpKGlNLMchM7q4Wjg2CUpjHLaL8yYPH" crossorigin="anonymous"></script>

<script type="application/javascript">
var doNotTrack = false;
if (!doNotTrack) {
	(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
	(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
	m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
	})(window,document,'script','https://www.google-analytics.com/analytics.js','ga');
	ga('create', 'UA-41178626-2', 'auto');
	
	ga('send', 'pageview');
}
</script>
</head>
<body>
<div class="reveal">
<div class="slides">
<section>
<link rel="stylesheet" href="style.css">
<h1 id="統計モデリング概論-dshc-2021"><a href=".">統計モデリング概論 DSHC 2021</a></h1>
<div class="author">
岩嵜 航 (Watal M. Iwasaki, PhD)
</div>
<div class="affiliation">
東北大学 生命科学研究科 進化ゲノミクス分野 特任助教<br>
(Graduate School of Life Sciences, Tohoku University)
</div>
<ol>
<li><a href="1-introduction.html">導入</a>
<li><a href="2-stats-model.html">統計モデルの基本</a>
<li><a href="3-glm.html">一般化線形モデル</a>
<li class="current-deck"><a href="4-bayesian.html">階層ベイズモデル</a>
</ol>
<div class="footnote">
2021-06-30 東京海上 Data Science Hill Climb
<a href="https://heavywatal.github.io/slides/tokiomarine2021/">https://heavywatal.github.io/slides/tokiomarine2021/</a>
</div>

</section>
<section>
<h2 id="コイントス4回たまたま表が1回だったら">コイントス4回、たまたま表が1回だったら</h2>
<p>最尤法(頻度主義): 表が出る確率1/4のコインだろう。</p>
<p>ベイズ主義: 1/4らへんにピークはあるが、不確実さも確率分布で表現。
加法定理・乗法定理を駆使して評価しよう。</p>
<div>\[\begin{split}
p(X)   &= \sum^Y p(X,Y) \\
p(X,Y) &= p(Y \mid X) P(X)
\end{split}\]</div>
</section>
<section>
<h2 id="コイントスの回数が増えていったら">コイントスの回数が増えていったら</h2>
<p>最尤法(頻度主義): 推定値が1/2に近づいていく</p>
<p>ベイズ主義: 確率分布がどんどん尖っていく</p>

</section>
<section>
<h2 id="ベイズの定理">ベイズの定理</h2>
<p>モデルの事後分布 $p(\mathcal M _i \mid \mathcal D)$ は、</p>
<ul>
<li>$p(\mathcal M _i)$: どのモデルがアリかなという好み(事前分布)と、</li>
<li>$p(\mathcal D \mid \mathcal M _i)$:
そのモデルの下での観察データの出やすさ
(<em>model evidence</em>; <em>marginal likelihood</em> <strong>周辺尤度</strong>)</li>
</ul>
<p>の積に比例する (<strong>式 3.66</strong>)。</p>
<div>\[
p(\mathcal M _i \mid \mathcal D)
   \propto p(\mathcal M _i) p(\mathcal D \mid \mathcal M _i)
\]</div>
<p>条件付き確率、事前分布、事後分布、尤度</p>
<div>\[
\text{posterior} \propto \text{prior} \times \text{likelihood}
\]</div>
</section>
<section>
<h2 id="逐次学習">逐次学習</h2>
<p>データを追加するごとに事後分布が更新される。
</section>
<section>
<h2 id="ベータ分布を例に">ベータ分布を例に</h2>
<p>コイントス3回続けて表が出たからといって $p = 1$ なわけがない、
という事前情報をうまく取り入れて過学習を避けたい。</p>
<div>\[\begin{split}
\text{Binomial}(m \mid n,~p) = \binom n m p^m (1 - p)^{(n - m)}
\end{split}\]</div>
<div>\[\begin{split}
\text{Beta}(\mu \mid a, b) =
   \frac{\Gamma(a + b)}{\Gamma(a) \Gamma(b)} \mu^{a-1} (1 - \mu)^{b-1}
\end{split}\]</div>
<p>sequential approach 逐次学習</p>

</section>
<section>
<h2 id="共役事前分布">共役事前分布</h2>
<p>事後分布が事前分布と同じ形なので計算しやすい、という組み合わせ。</p>
<table>
<thead>
<tr>
<th>尤度関数</th>
<th>共役事前分布</th>
</tr>
</thead>
<tbody>
<tr>
<td>二項分布</td>
<td>ベータ分布</td>
</tr>
<tr>
<td>ポアソン分布</td>
<td>ガンマ分布</td>
</tr>
<tr>
<td>正規分布</td>
<td>ガンマ分布</td>
</tr>
<tr>
<td>正規分布 (分散既知)</td>
<td>正規分布</td>
</tr>
</tbody>
</table>

</section>
<section>
<h2 id="解析に解くのは難しい">解析に解くのは難しい</h2>
<p>コイン投げモデルのベータ分布は美しい例だけど現実はもっと複雑。</p>
<p>→現実的な計算方法としてのMCMC</p>
<p>事後分布的なものから乱数サンプルを集めて事後分布の代わりにする</p>
<p>このとき、共役事前分布を使うことが正しいとも限らない。<br>
計算コストがかかっても<strong>無情報事前分布</strong>を使うのが安全。</p>

</section>
<section>
<h2 id="モンテカルロ法">モンテカルロ法</h2>
<p>円の面積</p>
<p><img src="figure/circle-1.png" alt="plot of chunk circle"></p>
<p>$4 \times \frac {318} {400} = 3.18$</p>
<p>これが高次元になっていくと？</p>

</section>
<section>
<h2 id="高次元になるほど当たらなくなる">高次元になるほど当たらなくなる</h2>
<p>N次元球の体積 / N次元の立方体</p>
<ul>
<li>2次元: $\frac {\pi r ^ 2} {(2r) ^ 2} = \frac \pi 4$</li>
<li>3次元: $\frac {\frac 4 3 \pi r ^ 3} {(2r) ^ 3} = \frac \pi 6$</li>
<li>N次元: $\frac {\frac {\pi ^ {N/2}} {\Gamma (N/2 + 1)} r ^ N} {(2r) ^ N} = \frac {\pi ^ {N/2}} {2^N \Gamma (N/2 + 1)} \to 0$</li>
</ul>

</section>
<section>
<h2 id="マルコフ連鎖">マルコフ連鎖</h2>
<p>記憶を失う
</section>
<section>
<h2 id="パラメータを更新する方法いろいろ">パラメータを更新する方法いろいろ</h2>
<ul>
<li>Metropolis</li>
<li>Gibbs</li>
<li>Hamiltonian</li>
</ul>

</section>
<section>
<h2 id="山をうろうろした軌跡事後分布">山をうろうろした軌跡→事後分布</h2>
<p>尤度に比例した確率分布</p>
<p>MAP推定</p>

</section>
<section>
<h2 id="trace-plot-mcmc結果の可視化">trace plot: MCMC結果の可視化</h2>
<ul>
<li>chain</li>
<li>warm up / burn in</li>
<li>収束</li>
</ul>

</section>
<section>
<h2 id="mcmcソフトウェア">MCMCソフトウェア</h2>
<ul>
<li>WinBUGS
<ul>
<li>Windowsでしか動かない</li>
</ul>
</li>
<li>JAGS
<ul>
<li>開発停滞、マニュアルや用例が不足</li>
</ul>
</li>
<li><strong>Stan</strong>
<ul>
<li>開発も利用も活発</li>
<li>マニュアルや用例も充実、エラーも読みやすい。</li>
<li>NUTSやADVIなどのアルゴリズムで早く収束</li>
</ul>
</li>
</ul>

</section>
<section>
<h2 id="stan">Stan</h2>
<ul>
<li>C++で書かれている</li>
<li>Stan言語でモデルを書く</li>
<li>PythonやRなどから呼び出して使うのが便利</li>
</ul>

</section>
<section>
<h2 id="stan言語でモデルを書く">Stan言語でモデルを書く</h2>
<pre><code class="language-stan" data-lang="stan">data {
  int length;
  real x[length];
}

parameters {
  real mu;
  real&lt;lower=0&gt; sigma;
}

model {
  x ~ normal(mu, sigma);
}
</code></pre>
</section>
<section>
<h2 id="stan言語の7種のブロック順番厳守">Stan言語の7種のブロック、順番厳守</h2>
<dl>
<dt><code>functions {...}</code></dt>
<dd>関数を定義できる。</dd>
<dt><code>data {...}</code></dt>
<dd>Rから受け取る定数の宣言。</dd>
<dt><code>transformed data {...}</code></dt>
<dd>定数の宣言と代入。
決め打ちのハイパーパラメータとか。
決定論的な変換のみ可能。</dd>
<dt><code>parameters {...}</code></dt>
<dd>サンプリングされる変数の宣言。</dd>
<dt><code>transformed parameters {...}</code></dt>
<dd>変数の宣言と代入。
モデルで使いやすい形にパラメータを変形しておくとか？</dd>
<dt><code>model {...}</code></dt>
<dd>唯一の必須ブロック。
サンプルされないローカル変数を宣言してもよいが、制約をかけることはできない。</dd>
<dt><code>generated quantities {...}</code></dt>
<dd>サンプリング後の値を使って好きなことをするとこ？
<code>normal_rng()</code>などによる乱数生成が許される唯一のブロック。
ここを使わずR/Pythonで結果を受け取ってからどうにかするほうが簡単。</dd>
</dl>

</section>
<section>
<h2 id="functions-"><code>functions {...}</code></h2>
<p>関数定義
</section>
<section>
<h2 id="data-"><code>data {...}</code></h2>
<p>Rから受け取る定数の宣言。
</section>
<section>
<h2 id="transformed-data-"><code>transformed data {...}</code></h2>
<p>定数の宣言と代入。
決め打ちのハイパーパラメータとか。
決定論的な変換のみ可能。
</section>
<section>
<h2 id="parameters-"><code>parameters {...}</code></h2>
<p>サンプリングされる変数の宣言。</p>
<p>値の範囲を指定する。</p>

</section>
<section>
<h2 id="transformed-parameters-"><code>transformed parameters {...}</code></h2>
<p>変数の宣言と代入。
モデルで使いやすい形にパラメータを変形しておくとか？
</section>
<section>
<h2 id="model-"><code>model {...}</code></h2>
<p>唯一の必須ブロック。</p>
<p>サンプルされないローカル変数を宣言してもよいが、制約をかけることはできない。</p>

</section>
<section>
<h2 id="generated-quantities-"><code>generated quantities {...}</code></h2>
<p>サンプリング後の値を使って好きなことをするとこ？
<code>normal_rng()</code>などによる乱数生成が許される唯一のブロック。
ここを使わずR/Pythonで結果を受け取ってからどうにかするほうが簡単。
</section>
<section>
<h2 id="階層じゃないベイズモデルを作ってみる">階層じゃないベイズモデルを作ってみる</h2>
<p>種子の色と数。二項分布、ベータ分布。
</section>
<section>
<h2 id="普通の線形単回帰をわざわざstanでやってみる">普通の線形単回帰をわざわざStanでやってみる</h2>

</section>
<section>
<h2 id="過分散を階層ベイズモデルで扱う">過分散を階層ベイズモデルで扱う</h2>
<p>個体差→過分散
</section>
<section>
<h2 id="階層ベイズモデルのほかの応用先">階層ベイズモデルのほかの応用先</h2>
<ul>
<li>時系列モデル (状態空間モデル)</li>
<li>空間構造のあるモデル (e.g., CARモデル)</li>
<li>欠損値の補完</li>
</ul>

</section>
</div>
</div>
<script src="/slides/lib/reveal.js/reveal.js"></script>
<script src="/slides/lib/reveal.js/plugin/notes.js"></script>
<script>
Reveal.initialize({
  width: 960,
  height: 720,
  margin: 0,
  controls: true,
  controlsLayout: 'bottom-right',
  controlsTutorial: false,
  controlsBackArrows: 'faded',
  progress: false,
  slideNumber: 'c/t',
  showSlideNumber: 'all',
  hashOneBasedIndex: true,
  hash: true,
  history: false,
  keyboard: true,
  overview: true,
  center: false,
  touch: true,
  loop: false,
  rtl: false,
  navigationMode: 'linear',
  shuffle: false,
  fragments: true,
  fragmentInURL: true,
  embedded: false,
  help: true,
  showNotes: false,
  autoPlayMedia: null,
  preloadIframes: null,
  mouseWheel: false,
  previewLinks: false,
  transition: 'none',
  transitionSpeed: 'fast',
  backgroundTransition: 'none',
  pdfMaxPagesPerSlide: 1,
  pdfSeparateFragments: false,
  viewDistance: 2,
  plugins: [ RevealNotes ]
});
</script>
<script>
{
const reload_all_img = function() {
  const imgs = document.getElementsByTagName("img");
  for (let i = 0; i < imgs.length; ++i) {
    const src = imgs[i].src;
    imgs[i].src += "?q";
    imgs[i].src = src;
  }
};
const reload_src_element = function(ev) {
  const original_src = ev.srcElement.src;
  ev.srcElement.src += "?q";
  ev.srcElement.src = original_src;
};
const reload_src = function(ev) {
  if (ev.shiftKey || ev.metaKey || ev.altKey) {
    reload_all_img();
  } else {
    reload_src_element(ev);
  }
};
const img_elements = document.getElementsByTagName("img");
for (let i = 0; i < img_elements.length; ++i) {
  img_elements[i].onclick = reload_src;
}
};
</script>
</body>
</html>
